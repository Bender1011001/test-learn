"""
Database models for task management and tracking.

This module defines the database models for storing and managing tasks
generated by the Proposer agent, including task metadata, execution
results, and performance tracking.
"""

from sqlalchemy import Column, Integer, String, Text, DateTime, Float, Boolean, JSON, Enum as SQLEnum
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
import enum

from ..base import Base


class TaskDifficultyEnum(enum.Enum):
    """Task difficulty levels"""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


class TaskCategoryEnum(enum.Enum):
    """Task categories/domains"""
    CODING = "coding"
    REASONING = "reasoning"
    CREATIVE = "creative"
    ANALYTICAL = "analytical"
    PROBLEM_SOLVING = "problem_solving"
    DATA_ANALYSIS = "data_analysis"


class TaskPriorityEnum(enum.Enum):
    """Task priority levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class TaskStatusEnum(enum.Enum):
    """Task execution status"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class Task(Base):
    """Model for storing generated tasks."""
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True, index=True)
    task_id = Column(String(100), unique=True, index=True, nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text, nullable=False)
    category = Column(SQLEnum(TaskCategoryEnum), nullable=False, index=True)
    difficulty = Column(SQLEnum(TaskDifficultyEnum), nullable=False, index=True)
    priority = Column(SQLEnum(TaskPriorityEnum), default=TaskPriorityEnum.MEDIUM, index=True)
    status = Column(SQLEnum(TaskStatusEnum), default=TaskStatusEnum.PENDING, index=True)
    
    # Task metadata
    complexity_score = Column(Float, nullable=False, index=True)
    estimated_duration = Column(Integer, default=30)  # minutes
    success_criteria = Column(JSON)  # List of success criteria
    evaluation_metrics = Column(JSON)  # Dictionary of evaluation metrics
    prerequisites = Column(JSON)  # List of prerequisites
    tags = Column(JSON)  # List of tags
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Generation metadata
    generated_by_agent = Column(String(100), default="ProposerAgent")
    generation_context = Column(JSON)  # Context used for generation
    
    # Relationships
    executions = relationship("TaskExecution", back_populates="task", cascade="all, delete-orphan")
    feedback_entries = relationship("TaskFeedback", back_populates="task", cascade="all, delete-orphan")

    def __init__(self, **kwargs):
        # Generate task_id if not provided
        if 'task_id' not in kwargs:
            kwargs['task_id'] = f"task_{int(datetime.utcnow().timestamp())}_{str(uuid.uuid4())[:8]}"
        super().__init__(**kwargs)

    def to_dict(self):
        """Convert task to dictionary representation"""
        return {
            "id": self.id,
            "task_id": self.task_id,
            "title": self.title,
            "description": self.description,
            "category": self.category.value if self.category else None,
            "difficulty": self.difficulty.value if self.difficulty else None,
            "priority": self.priority.value if self.priority else None,
            "status": self.status.value if self.status else None,
            "complexity_score": self.complexity_score,
            "estimated_duration": self.estimated_duration,
            "success_criteria": self.success_criteria,
            "evaluation_metrics": self.evaluation_metrics,
            "prerequisites": self.prerequisites,
            "tags": self.tags,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "generated_by_agent": self.generated_by_agent,
            "generation_context": self.generation_context
        }


class TaskExecution(Base):
    """Model for storing task execution results."""
    __tablename__ = "task_executions"

    id = Column(Integer, primary_key=True, index=True)
    execution_id = Column(String(100), unique=True, index=True, nullable=False)
    task_id = Column(String(100), nullable=False, index=True)
    
    # Execution details
    executor_agent = Column(String(100), default="ExecutorAgent")
    status = Column(SQLEnum(TaskStatusEnum), nullable=False, index=True)
    
    # Results
    execution_output = Column(JSON)  # Detailed execution results
    success_criteria_met = Column(JSON)  # List of criteria that were met
    execution_time = Column(Float)  # Execution time in seconds
    error_message = Column(Text, nullable=True)
    
    # Performance metrics
    quality_score = Column(Float, nullable=True)  # Overall quality score
    efficiency_score = Column(Float, nullable=True)  # Efficiency score
    completeness_score = Column(Float, nullable=True)  # Completeness score
    
    # Timestamps
    started_at = Column(DateTime, nullable=False, index=True)
    completed_at = Column(DateTime, nullable=True, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    task = relationship("Task", back_populates="executions")
    feedback_entries = relationship("TaskFeedback", back_populates="execution", cascade="all, delete-orphan")

    def __init__(self, **kwargs):
        # Generate execution_id if not provided
        if 'execution_id' not in kwargs:
            kwargs['execution_id'] = f"exec_{int(datetime.utcnow().timestamp())}_{str(uuid.uuid4())[:8]}"
        super().__init__(**kwargs)

    def to_dict(self):
        """Convert execution to dictionary representation"""
        return {
            "id": self.id,
            "execution_id": self.execution_id,
            "task_id": self.task_id,
            "executor_agent": self.executor_agent,
            "status": self.status.value if self.status else None,
            "execution_output": self.execution_output,
            "success_criteria_met": self.success_criteria_met,
            "execution_time": self.execution_time,
            "error_message": self.error_message,
            "quality_score": self.quality_score,
            "efficiency_score": self.efficiency_score,
            "completeness_score": self.completeness_score,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }


class TaskFeedback(Base):
    """Model for storing feedback on task executions."""
    __tablename__ = "task_feedback"

    id = Column(Integer, primary_key=True, index=True)
    feedback_id = Column(String(100), unique=True, index=True, nullable=False)
    task_id = Column(String(100), nullable=False, index=True)
    execution_id = Column(String(100), nullable=True, index=True)
    
    # Feedback source
    reviewer_agent = Column(String(100), default="PeerReviewer")
    feedback_type = Column(String(50), default="peer_review")  # peer_review, user_feedback, auto_evaluation
    
    # Feedback content
    overall_rating = Column(Float, nullable=False)  # 1-10 scale
    strengths = Column(JSON)  # List of strengths
    areas_for_improvement = Column(JSON)  # List of improvement areas
    effectiveness_score = Column(Float, nullable=True)
    correctness_score = Column(Float, nullable=True)
    detailed_feedback = Column(Text, nullable=True)
    
    # Additional metrics
    task_difficulty_assessment = Column(String(50), nullable=True)  # too_easy, appropriate, too_hard
    task_quality_rating = Column(Float, nullable=True)  # Rating of the task itself
    execution_quality_rating = Column(Float, nullable=True)  # Rating of the execution
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    
    # Relationships
    task = relationship("Task", back_populates="feedback_entries")
    execution = relationship("TaskExecution", back_populates="feedback_entries")

    def __init__(self, **kwargs):
        # Generate feedback_id if not provided
        if 'feedback_id' not in kwargs:
            kwargs['feedback_id'] = f"feedback_{int(datetime.utcnow().timestamp())}_{str(uuid.uuid4())[:8]}"
        super().__init__(**kwargs)

    def to_dict(self):
        """Convert feedback to dictionary representation"""
        return {
            "id": self.id,
            "feedback_id": self.feedback_id,
            "task_id": self.task_id,
            "execution_id": self.execution_id,
            "reviewer_agent": self.reviewer_agent,
            "feedback_type": self.feedback_type,
            "overall_rating": self.overall_rating,
            "strengths": self.strengths,
            "areas_for_improvement": self.areas_for_improvement,
            "effectiveness_score": self.effectiveness_score,
            "correctness_score": self.correctness_score,
            "detailed_feedback": self.detailed_feedback,
            "task_difficulty_assessment": self.task_difficulty_assessment,
            "task_quality_rating": self.task_quality_rating,
            "execution_quality_rating": self.execution_quality_rating,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }


class TaskQueue(Base):
    """Model for managing task queues and prioritization."""
    __tablename__ = "task_queues"

    id = Column(Integer, primary_key=True, index=True)
    queue_id = Column(String(100), unique=True, index=True, nullable=False)
    queue_name = Column(String(100), nullable=False)
    description = Column(Text, nullable=True)
    
    # Queue configuration
    max_size = Column(Integer, default=100)
    auto_generation_enabled = Column(Boolean, default=True)
    generation_rate_limit = Column(Integer, default=10)  # tasks per minute
    
    # Queue statistics
    total_tasks_generated = Column(Integer, default=0)
    total_tasks_completed = Column(Integer, default=0)
    average_completion_time = Column(Float, nullable=True)
    average_quality_score = Column(Float, nullable=True)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_generation_time = Column(DateTime, nullable=True)

    def __init__(self, **kwargs):
        # Generate queue_id if not provided
        if 'queue_id' not in kwargs:
            kwargs['queue_id'] = f"queue_{int(datetime.utcnow().timestamp())}_{str(uuid.uuid4())[:8]}"
        super().__init__(**kwargs)

    def to_dict(self):
        """Convert queue to dictionary representation"""
        return {
            "id": self.id,
            "queue_id": self.queue_id,
            "queue_name": self.queue_name,
            "description": self.description,
            "max_size": self.max_size,
            "auto_generation_enabled": self.auto_generation_enabled,
            "generation_rate_limit": self.generation_rate_limit,
            "total_tasks_generated": self.total_tasks_generated,
            "total_tasks_completed": self.total_tasks_completed,
            "average_completion_time": self.average_completion_time,
            "average_quality_score": self.average_quality_score,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
            "last_generation_time": self.last_generation_time.isoformat() if self.last_generation_time else None
        }


class TaskGenerationSettings(Base):
    """Model for storing task generation settings and preferences."""
    __tablename__ = "task_generation_settings"

    id = Column(Integer, primary_key=True, index=True)
    settings_id = Column(String(100), unique=True, index=True, nullable=False)
    name = Column(String(100), nullable=False)
    
    # Generation preferences
    preferred_categories = Column(JSON)  # List of preferred categories
    preferred_difficulties = Column(JSON)  # Distribution of difficulties
    complexity_range = Column(JSON)  # Min/max complexity scores
    
    # Quality controls
    min_complexity_score = Column(Float, default=2.0)
    max_complexity_score = Column(Float, default=9.0)
    diversity_threshold = Column(Float, default=0.7)
    quality_threshold = Column(Float, default=6.0)
    
    # Rate limiting
    max_tasks_per_minute = Column(Integer, default=10)
    max_tasks_per_hour = Column(Integer, default=100)
    max_tasks_per_day = Column(Integer, default=1000)
    
    # Adaptive settings
    enable_adaptive_difficulty = Column(Boolean, default=True)
    enable_feedback_learning = Column(Boolean, default=True)
    success_rate_target = Column(Float, default=0.7)  # Target success rate
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __init__(self, **kwargs):
        # Generate settings_id if not provided
        if 'settings_id' not in kwargs:
            kwargs['settings_id'] = f"settings_{int(datetime.utcnow().timestamp())}_{str(uuid.uuid4())[:8]}"
        super().__init__(**kwargs)

    def to_dict(self):
        """Convert settings to dictionary representation"""
        return {
            "id": self.id,
            "settings_id": self.settings_id,
            "name": self.name,
            "preferred_categories": self.preferred_categories,
            "preferred_difficulties": self.preferred_difficulties,
            "complexity_range": self.complexity_range,
            "min_complexity_score": self.min_complexity_score,
            "max_complexity_score": self.max_complexity_score,
            "diversity_threshold": self.diversity_threshold,
            "quality_threshold": self.quality_threshold,
            "max_tasks_per_minute": self.max_tasks_per_minute,
            "max_tasks_per_hour": self.max_tasks_per_hour,
            "max_tasks_per_day": self.max_tasks_per_day,
            "enable_adaptive_difficulty": self.enable_adaptive_difficulty,
            "enable_feedback_learning": self.enable_feedback_learning,
            "success_rate_target": self.success_rate_target,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }